<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>3D 骰盅 (Sic Bo)</title>
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body { 
            margin: 0; 
            padding: 0;
            overflow: hidden; 
            background-color: #050505; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            touch-action: none;
            height: 100%;
            width: 100%;
        }
        #canvas-container { 
            width: 100%; 
            height: 100%; 
            display: block;
            position: fixed;
            top: 0;
            left: 0;
        }
        
        #ui-layer {
            position: fixed;
            bottom: max(20px, env(safe-area-inset-bottom, 20px));
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            flex-direction: column;
            gap: 15px;
            padding: 0 15px;
            z-index: 100;
        }

        .btn {
            pointer-events: auto;
            background: linear-gradient(135deg, #d4af37, #aa8822);
            border: 1px solid #ffd700;
            color: #fff;
            padding: 14px 45px;
            font-size: 18px;
            font-weight: 600;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.4);
            transition: transform 0.1s, box-shadow 0.1s;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            -webkit-user-select: none;
            user-select: none;
            min-width: 160px;
        }

        .btn:active {
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(212, 175, 55, 0.3);
        }
        
        .btn:disabled {
            background: #444;
            border-color: #555;
            color: #888;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        #result-display {
            font-size: 20px;
            color: #ffd700;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            background: rgba(0, 0, 0, 0.75);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: auto;
            font-family: monospace;
            text-align: center;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #888;
            font-size: 14px;
            z-index: 200;
        }

        /* 移动端适配 */
        @media (max-width: 480px) {
            .btn {
                padding: 16px 40px;
                font-size: 16px;
                min-width: 140px;
            }
            #result-display {
                font-size: 18px;
                padding: 8px 16px;
            }
            #ui-layer {
                gap: 12px;
            }
        }

        /* 横屏适配 */
        @media (max-height: 500px) and (orientation: landscape) {
            #ui-layer {
                bottom: 10px;
                flex-direction: row;
                gap: 20px;
            }
            .btn {
                padding: 10px 30px;
                font-size: 14px;
            }
            #result-display {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>

<div id="loading">资源初始化...</div>

<div id="canvas-container"></div>

<div id="ui-layer">
    <div id="result-display">准备就绪</div>
    <button id="shake-btn" class="btn">SHAKE</button>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { RoundedBoxGeometry } from 'three/addons/geometries/RoundedBoxGeometry.js';
    import * as CANNON from 'cannon-es';

    // --- 全局变量 ---
    let scene, camera, renderer, controls;
    let world, diceBodies = [], diceMeshes = [];
    let glassCoverMesh, baseMesh;
    let isShaking = false;
    let physicsMaterial;
    
    // 检测移动端
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
                     || window.innerWidth < 768;
    
    // 配置参数 - 优化清晰度
    const DICE_SIZE = 1.3; 
    const CONTAINER_RADIUS = 5.5; 
    const DOME_HEIGHT = CONTAINER_RADIUS;
    const TEXTURE_SIZE = 512; // 统一使用高分辨率纹理
    const SHADOW_MAP_SIZE = isMobile ? 1024 : 2048;
    const GEOMETRY_SEGMENTS = 96; // 高分段数确保光滑
    
    const resultDisplay = document.getElementById('result-display');
    const shakeBtn = document.getElementById('shake-btn');

    function init() {
        document.getElementById('loading').style.display = 'none';

        // 1. 场景
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);

        // 2. 相机 - 根据屏幕比例调整
        const aspect = window.innerWidth / window.innerHeight;
        const isPortrait = aspect < 1; // 竖屏
        const fov = isPortrait ? 55 : 40; // 竖屏增大视角
        camera = new THREE.PerspectiveCamera(fov, aspect, 0.1, 100);
        updateCameraPosition();
        camera.lookAt(0, 0, 0);

        // 3. 渲染器 - 优化清晰度
        renderer = new THREE.WebGLRenderer({ 
            antialias: true, // 始终开启抗锯齿
            alpha: false,
            powerPreference: 'high-performance'
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.4;
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 提高像素比
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // 4. 控制器 - 支持触摸
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.maxPolarAngle = Math.PI / 2.2;
        controls.minDistance = isMobile ? 15 : 10;
        controls.maxDistance = isMobile ? 40 : 35;
        controls.enablePan = false;
        controls.rotateSpeed = isMobile ? 0.5 : 1.0;
        controls.target.set(0, 1, 0); // 对准骰盅中心
        controls.touches = {
            ONE: THREE.TOUCH.ROTATE,
            TWO: THREE.TOUCH.DOLLY_ROTATE
        };

        // 5. 核心组件
        setupLighting();
        setupPhysics();
        createTable(); 
        createCupBase();
        createPhysicsCage(); // 物理笼子（包含墙壁和天花板）
        createGlassCover();
        createDice(3);

        window.addEventListener('resize', onWindowResize);
        
        // 支持触摸和点击
        shakeBtn.addEventListener('click', shakeDice);
        shakeBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            shakeDice();
        }, { passive: false });

        // 防止双击缩放
        document.addEventListener('dblclick', (e) => e.preventDefault());
        
        // 处理屏幕方向变化
        window.addEventListener('orientationchange', () => {
            setTimeout(onWindowResize, 100);
        });

        animate();
    }

    function setupLighting() {
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        // 主聚光灯
        const spotLight = new THREE.SpotLight(0xfff8ee, 300);
        spotLight.position.set(5, 20, 5);
        spotLight.angle = Math.PI / 5;
        spotLight.penumbra = 0.5;
        spotLight.castShadow = true;
        spotLight.shadow.mapSize.width = SHADOW_MAP_SIZE;
        spotLight.shadow.mapSize.height = SHADOW_MAP_SIZE;
        scene.add(spotLight);

        // 顶部光源 - 照亮玻璃罩顶部
        const topLight = new THREE.PointLight(0xffffff, 100);
        topLight.position.set(0, 15, 0);
        scene.add(topLight);

        // 侧面光源 - 产生玻璃边缘高光
        const leftLight = new THREE.PointLight(0xaaccff, 80);
        leftLight.position.set(-10, 8, -10);
        scene.add(leftLight);
        
        const rightLight = new THREE.PointLight(0xffddaa, 80);
        rightLight.position.set(10, 8, 10);
        scene.add(rightLight);

        // 前方补光 - 让玻璃罩正面更亮
        const frontLight = new THREE.PointLight(0xffffff, 50);
        frontLight.position.set(0, 6, 12);
        scene.add(frontLight);

        // 环境贴图（简单的渐变天空）
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        const envScene = new THREE.Scene();
        envScene.background = new THREE.Color(0x222233);
        
        // 添加一些假的环境光点
        const envLight1 = new THREE.Mesh(
            new THREE.SphereGeometry(0.5),
            new THREE.MeshBasicMaterial({ color: 0xffffff })
        );
        envLight1.position.set(5, 8, 5);
        envScene.add(envLight1);
        
        const envTexture = pmremGenerator.fromScene(envScene).texture;
        scene.environment = envTexture;
    }

    function setupPhysics() {
        world = new CANNON.World();
        world.gravity.set(0, -9.82 * 3, 0); 
        world.allowSleep = true;

        const groundMat = new CANNON.Material();
        const diceMat = new CANNON.Material();
        const wallMat = new CANNON.Material();

        const diceDiceContact = new CANNON.ContactMaterial(diceMat, diceMat, {
            friction: 0.1,
            restitution: 0.5 
        });
        
        const diceGroundContact = new CANNON.ContactMaterial(groundMat, diceMat, {
            friction: 0.3,
            restitution: 0.3 
        });

        // 墙壁弹性稍微降低，防止无限反弹加速
        const diceWallContact = new CANNON.ContactMaterial(wallMat, diceMat, {
            friction: 0.0, 
            restitution: 0.6 
        });

        world.addContactMaterial(diceDiceContact);
        world.addContactMaterial(diceGroundContact);
        world.addContactMaterial(diceWallContact);

        physicsMaterial = { ground: groundMat, dice: diceMat, wall: wallMat };

        const groundBody = new CANNON.Body({
            mass: 0,
            shape: new CANNON.Plane(),
            material: groundMat
        });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(groundBody);
    }

    // --- 物理笼子：墙壁 + 天花板 ---
    function createPhysicsCage() {
        const segments = 16; 
        const angleStep = (Math.PI * 2) / segments;
        const radius = CONTAINER_RADIUS - 0.2; 
        const height = DOME_HEIGHT;

        // 1. 四周的墙壁
        for (let i = 0; i < segments; i++) {
            const angle = i * angleStep;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            
            const wallBody = new CANNON.Body({ mass: 0, material: physicsMaterial.wall });
            const width = 2 * radius * Math.tan(Math.PI / segments) * 1.05; 
            
            // 墙壁加高，防止飞出
            const shape = new CANNON.Box(new CANNON.Vec3(width / 2, height, 0.5));
            wallBody.addShape(shape);

            wallBody.position.set(x, height / 2, z);
            wallBody.quaternion.setFromEuler(0, -angle + Math.PI/2, 0); 

            world.addBody(wallBody);
        }

        // 2. 隐形天花板 (防止向上飞出)
        const ceilingBody = new CANNON.Body({ mass: 0, material: physicsMaterial.wall });
        const ceilingShape = new CANNON.Box(new CANNON.Vec3(radius, 0.5, radius));
        ceilingBody.addShape(ceilingShape);
        // 位置设在半球体顶部略低一点的地方
        ceilingBody.position.set(0, DOME_HEIGHT - 0.5, 0); 
        world.addBody(ceilingBody);
    }

    // 创建骰子纹理 - 高清大点数
    function createDiceTexture(number) {
        const size = TEXTURE_SIZE;
        const canvas = document.createElement('canvas');
        canvas.width = size; 
        canvas.height = size;
        const ctx = canvas.getContext('2d');

        // 纯白底色
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, size, size);

        // 点数位置
        const c = size / 2;
        const l = size * 0.22;
        const f = size * 0.78;
        const r = size * 0.12; // 点的半径 - 更大

        // 绘制点数
        function drawPip(x, y, isRed, scale = 1) {
            const radius = r * scale;
            
            // 主点
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            
            if (isRed) {
                ctx.fillStyle = '#e60000'; // 鲜红色
            } else {
                ctx.fillStyle = '#000000'; // 纯黑色
            }
            ctx.fill();
        }

        const isRed = (number === 1 || number === 4);

        if (number === 1) {
            drawPip(c, c, true, 1.6); // 1点更大
        } else if (number === 2) {
            drawPip(f, l, false);
            drawPip(l, f, false);
        } else if (number === 3) {
            drawPip(f, l, false);
            drawPip(c, c, false);
            drawPip(l, f, false);
        } else if (number === 4) {
            drawPip(l, l, true);
            drawPip(f, l, true);
            drawPip(l, f, true);
            drawPip(f, f, true);
        } else if (number === 5) {
            drawPip(l, l, false);
            drawPip(f, l, false);
            drawPip(c, c, false);
            drawPip(l, f, false);
            drawPip(f, f, false);
        } else if (number === 6) {
            drawPip(l, l, false);
            drawPip(f, l, false);
            drawPip(l, c, false);
            drawPip(f, c, false);
            drawPip(l, f, false);
            drawPip(f, f, false);
        }

        const texture = new THREE.CanvasTexture(canvas);
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy(); // 最大各向异性过滤
        texture.minFilter = THREE.LinearMipmapLinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.generateMipmaps = true;
        return texture;
    }

    function createDice(count) {
        // 使用圆角立方体 - RoundedBoxGeometry(宽, 高, 深, 分段数, 圆角半径)
        const geometry = new RoundedBoxGeometry(DICE_SIZE, DICE_SIZE, DICE_SIZE, 6, DICE_SIZE * 0.1);
        
        const textures = [];
        for(let i = 1; i <= 6; i++) textures.push(createDiceTexture(i));

        for (let i = 0; i < count; i++) {
            // 骰子材质 - 使用 MeshStandardMaterial 更清晰
            const diceMat = {
                roughness: 0.2,
                metalness: 0.0,
                envMapIntensity: 0.5
            };
            const materials = [
                new THREE.MeshStandardMaterial({ map: textures[0], ...diceMat }), // +X: 1
                new THREE.MeshStandardMaterial({ map: textures[5], ...diceMat }), // -X: 6
                new THREE.MeshStandardMaterial({ map: textures[1], ...diceMat }), // +Y: 2
                new THREE.MeshStandardMaterial({ map: textures[4], ...diceMat }), // -Y: 5
                new THREE.MeshStandardMaterial({ map: textures[2], ...diceMat }), // +Z: 3
                new THREE.MeshStandardMaterial({ map: textures[3], ...diceMat }), // -Z: 4
            ];

            const mesh = new THREE.Mesh(geometry, materials);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            const body = new CANNON.Body({
                mass: 8, 
                shape: new CANNON.Box(new CANNON.Vec3(DICE_SIZE/2, DICE_SIZE/2, DICE_SIZE/2)),
                material: physicsMaterial.dice,
                angularDamping: 0.4,
                linearDamping: 0.1
            });
            
            body.position.set((Math.random()-0.5)*2, 1 + i*1.5, (Math.random()-0.5)*2);
            body.quaternion.setFromEuler(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            
            world.addBody(body);
            diceBodies.push(body);
            scene.add(mesh);
            diceMeshes.push(mesh);
        }
    }

    function createTable() {
        // 底座边缘宽度减小 1/3（从 2/2.5 减小到 1.3/1.7）
        const geometry = new THREE.CylinderGeometry(CONTAINER_RADIUS + 1.3, CONTAINER_RADIUS + 1.7, 0.5, 64);
        const material = new THREE.MeshStandardMaterial({ 
            color: 0x0a0a0a, 
            roughness: 0.4,
            metalness: 0.2
        });
        const base = new THREE.Mesh(geometry, material);
        base.position.y = -0.25;
        base.receiveShadow = true;
        scene.add(base);

        // 内部的绿色绒布垫
        const padGeo = new THREE.CylinderGeometry(CONTAINER_RADIUS, CONTAINER_RADIUS, 0.1, 64);
        const padMat = new THREE.MeshStandardMaterial({ color: 0x004411, roughness: 1.0 });
        const pad = new THREE.Mesh(padGeo, padMat);
        pad.position.y = 0.05;
        pad.receiveShadow = true;
        scene.add(pad);
    }

    function createCupBase() {
        const geometry = new THREE.TorusGeometry(CONTAINER_RADIUS, 0.2, 16, 100);
        const material = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.2 });
        const ring = new THREE.Mesh(geometry, material);
        ring.rotation.x = -Math.PI/2;
        ring.position.y = 0.1;
        scene.add(ring);
    }

    // --- 真实玻璃罩效果 ---
    function createGlassCover() {
        // 主玻璃罩 - 清透玻璃（高分段数确保光滑）
        const glassSegments = 96; // 固定高分段数
        const geometry = new THREE.SphereGeometry(CONTAINER_RADIUS, glassSegments, glassSegments / 2, 0, Math.PI * 2, 0, Math.PI * 0.5);
        
        const material = new THREE.MeshPhysicalMaterial({
            color: 0xffffff,
            metalness: 0.0,
            roughness: 0.0,
            transmission: 0.99, // 更高透光率
            thickness: 0.0,
            ior: 1.0,
            envMapIntensity: 0.8,
            clearcoat: 0.5,
            clearcoatRoughness: 0.0,
            transparent: true,
            opacity: 0.05, // 更低不透明度，更清透
            side: THREE.FrontSide,
            depthWrite: false
        });

        glassCoverMesh = new THREE.Mesh(geometry, material);
        glassCoverMesh.position.y = 0.1;
        glassCoverMesh.renderOrder = 10;
        scene.add(glassCoverMesh);

        // 菲涅尔边缘效果 - 更淡的边缘高光
        const rimGeometry = new THREE.SphereGeometry(CONTAINER_RADIUS + 0.02, glassSegments, glassSegments / 2, 0, Math.PI * 2, 0, Math.PI * 0.5);
        const rimMaterial = new THREE.ShaderMaterial({
            uniforms: {
                rimColor: { value: new THREE.Color(0xffffff) },
                rimPower: { value: 4.0 },
                rimIntensity: { value: 0.2 } // 降低强度
            },
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vViewPosition = -mvPosition.xyz;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform vec3 rimColor;
                uniform float rimPower;
                uniform float rimIntensity;
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                void main() {
                    vec3 viewDir = normalize(vViewPosition);
                    float rim = 1.0 - max(0.0, dot(viewDir, vNormal));
                    rim = pow(rim, rimPower);
                    gl_FragColor = vec4(rimColor, rim * rimIntensity);
                }
            `,
            transparent: true,
            side: THREE.FrontSide,
            depthWrite: false
        });
        const rimMesh = new THREE.Mesh(rimGeometry, rimMaterial);
        rimMesh.position.y = 0.1;
        rimMesh.renderOrder = 11;
        scene.add(rimMesh);

        // 底部金属边框（增加分段数）
        const baseRingGeo = new THREE.TorusGeometry(CONTAINER_RADIUS, 0.15, 24, 128);
        const baseRingMat = new THREE.MeshStandardMaterial({
            color: 0x888888,
            metalness: 0.9,
            roughness: 0.2
        });
        const baseRing = new THREE.Mesh(baseRingGeo, baseRingMat);
        baseRing.rotation.x = -Math.PI / 2;
        baseRing.position.y = 0.12;
        scene.add(baseRing);

        // 主高光 - 简化，只保留一个
        const highlight1 = createHighlight(1.2, 0.8, 0.2);
        highlight1.position.set(1.2, DOME_HEIGHT - 1.2, -1.5);
        highlight1.rotation.set(-0.5, 0.4, 0);
        scene.add(highlight1);

        // 顶部小高光
        const topHighlight = createHighlight(1.0, 0.8, 0.1);
        topHighlight.position.set(0, DOME_HEIGHT - 0.5, 0);
        topHighlight.rotation.set(-Math.PI / 2, 0, 0);
        scene.add(topHighlight);
    }

    // 创建椭圆形高光
    function createHighlight(width, height, opacity) {
        const shape = new THREE.Shape();
        shape.ellipse(0, 0, width / 2, height / 2, 0, Math.PI * 2);
        const geo = new THREE.ShapeGeometry(shape, 32);
        const mat = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: opacity,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        return new THREE.Mesh(geo, mat);
    }

    // 触摸震动反馈
    function vibrate(pattern) {
        if ('vibrate' in navigator) {
            navigator.vibrate(pattern);
        }
    }

    function shakeDice() {
        if (isShaking) return;
        isShaking = true;
        shakeBtn.disabled = true;
        shakeBtn.textContent = "SHAKING...";
        resultDisplay.style.opacity = '0';

        // 触发震动反馈
        vibrate([50, 30, 50, 30, 50]);

        diceBodies.forEach(b => {
            b.wakeUp();
            b.velocity.set(0,0,0);
        });

        let shakeFrames = 0;
        const maxFrames = isMobile ? 50 : 60; // 移动端稍短
        const force = isMobile ? 100 : 120; // 移动端力度稍小

        const shaker = setInterval(() => {
            shakeFrames++;
            
            const offset = 0.2;
            glassCoverMesh.position.x = (Math.random()-0.5)*offset;
            glassCoverMesh.position.z = (Math.random()-0.5)*offset;

            // 每隔一段时间震动
            if (shakeFrames % 15 === 0) {
                vibrate(20);
            }

            diceBodies.forEach(body => {
                const toCenterX = -body.position.x * 2;
                const toCenterZ = -body.position.z * 2;
                
                body.applyImpulse(
                    new CANNON.Vec3(
                        (Math.random()-0.5)*force + toCenterX, 
                        Math.random()*force*0.6,
                        (Math.random()-0.5)*force + toCenterZ
                    ),
                    body.position
                );
                
                body.angularVelocity.set(Math.random()*20, Math.random()*20, Math.random()*20);
            });

            if (shakeFrames > maxFrames) {
                clearInterval(shaker);
                finishShake();
            }
        }, 16);
    }

    function finishShake() {
        glassCoverMesh.position.x = 0;
        glassCoverMesh.position.z = 0;
        setTimeout(checkResult, 2500);
    }

    function checkResult() {
        const results = [];
        const vectorY = new THREE.Vector3(0, 1, 0);

        diceMeshes.forEach((mesh, i) => {
            const matrix = new THREE.Matrix4().extractRotation(mesh.matrix);
            
            const faces = [
                { dir: new THREE.Vector3(1,0,0), val: 1 },
                { dir: new THREE.Vector3(-1,0,0), val: 6 },
                { dir: new THREE.Vector3(0,1,0), val: 2 },
                { dir: new THREE.Vector3(0,-1,0), val: 5 },
                { dir: new THREE.Vector3(0,0,1), val: 3 },
                { dir: new THREE.Vector3(0,0,-1), val: 4 },
            ];

            let maxDot = -1;
            let val = 1;

            for(let f of faces) {
                const worldDir = f.dir.clone().applyMatrix4(matrix);
                const dot = worldDir.dot(vectorY);
                if(dot > maxDot) {
                    maxDot = dot;
                    val = f.val;
                }
            }
            results.push(val);
        });

        const sum = results.reduce((a,b)=>a+b, 0);
        const isTriple = (results[0]===results[1] && results[1]===results[2]);
        let type = isTriple ? "豹子" : (sum >= 11 ? "大" : "小");
        
        resultDisplay.textContent = `${results.join('+')} = ${sum} (${type})`;
        resultDisplay.style.opacity = '1';
        
        // 结果震动反馈
        vibrate([100, 50, 100]);
        
        shakeBtn.textContent = "SHAKE";
        shakeBtn.disabled = false;
        isShaking = false;
    }

    function animate() {
        requestAnimationFrame(animate);
        
        // 物理步进 - 移动端降低精度提升性能
        const substeps = isMobile ? 3 : 5;
        world.step(1/60, 1/60, substeps); 

        // --- 核心修复：强制边界约束 (防止飞出) ---
        const maxRadius = CONTAINER_RADIUS - 0.7; // 允许的最大半径 (稍微小于物理墙)
        
        diceBodies.forEach(body => {
            // 1. 水平限制
            const distSq = body.position.x * body.position.x + body.position.z * body.position.z;
            if (distSq > maxRadius * maxRadius) {
                // 如果超出范围，计算角度
                const angle = Math.atan2(body.position.z, body.position.x);
                
                // 强制拉回边界内
                body.position.x = Math.cos(angle) * maxRadius;
                body.position.z = Math.sin(angle) * maxRadius;
                
                // 反转速度 (像撞墙一样反弹)
                const normalX = Math.cos(angle);
                const normalZ = Math.sin(angle);
                const dot = body.velocity.x * normalX + body.velocity.z * normalZ;
                
                if (dot > 0) { // 只有向外飞的时候才反弹
                    body.velocity.x -= 1.5 * dot * normalX;
                    body.velocity.z -= 1.5 * dot * normalZ;
                    // 能量衰减
                    body.velocity.x *= 0.5;
                    body.velocity.z *= 0.5;
                }
            }

            // 2. 垂直限制 (防止飞太高穿过天花板)
            if (body.position.y > DOME_HEIGHT - 0.8) {
                body.position.y = DOME_HEIGHT - 0.8;
                if (body.velocity.y > 0) {
                    body.velocity.y *= -0.5; // 向下反弹
                }
            }
        });
        // ------------------------------------

        for(let i=0; i<diceMeshes.length; i++){
            diceMeshes[i].position.copy(diceBodies[i].position);
            diceMeshes[i].quaternion.copy(diceBodies[i].quaternion);
        }

        controls.update();
        renderer.render(scene, camera);
    }

    // 根据屏幕比例更新相机位置
    function updateCameraPosition() {
        const aspect = window.innerWidth / window.innerHeight;
        const isPortrait = aspect < 1;
        
        if (isPortrait) {
            // 竖屏：相机拉远拉高，确保完整显示
            const distance = 28 / aspect; // 根据宽高比动态调整
            camera.position.set(0, Math.min(distance * 0.7, 25), Math.min(distance * 0.8, 28));
            camera.fov = 50;
        } else {
            // 横屏：正常视角
            camera.position.set(0, 16, 18);
            camera.fov = 40;
        }
        camera.updateProjectionMatrix();
        camera.lookAt(0, 0, 0);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        updateCameraPosition();
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (controls) {
            controls.target.set(0, 1, 0);
            controls.update();
        }
    }

    init();

</script>
</body>
</html>